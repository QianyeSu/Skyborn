!    -*- f90 -*-
! Note: the context of this file is case sensitive.

module sphcom_mod ! in src/sphcom.f90
    use iso_fortran_env, only: real64,int32
    use hrfft_mod, only: hrffti,hrfftf,hrfftb
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    real(kind=real64), private,parameter,optional,depend(pi) :: two_pi=2.0_wp*pi
    real(kind=real64), private,parameter,optional,depend(pi) :: half_pi=0.5_wp*pi
    real(kind=real64), private,parameter,optional :: sqrt2=1.4142135623730950488016887242096980785696718753769_wp
    real(kind=real64), private,parameter,optional :: sqrt3=1.7320508075688772935274463415058723669428052538104_wp
    real(kind=real64), private,parameter,optional :: sc10=1024.0_wp
    real(kind=real64), private,parameter,optional,depend(sc10) :: sc20=16
    real(kind=real64), private,parameter,optional,depend(sc20) :: sc40=256
    subroutine dnlfk(m,n,cp) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: m
        integer(kind=ip) intent(in) :: n
        real(kind=wp) dimension(:),intent(out) :: cp
    end subroutine dnlfk
    subroutine dnlft(m,n,theta,cp,pb) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: m
        integer(kind=ip) intent(in) :: n
        real(kind=wp) intent(in) :: theta
        real(kind=wp) dimension(:),intent(in) :: cp
        real(kind=wp) intent(out) :: pb
    end subroutine dnlft
    subroutine dnlftd(m,n,theta,cp,pb) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: m
        integer(kind=ip) intent(in) :: n
        real(kind=wp) intent(in) :: theta
        real(kind=wp) dimension(:),intent(in) :: cp
        real(kind=wp) intent(out) :: pb
    end subroutine dnlftd
    subroutine legin(mode,l,nlat,m,w,pmn,km) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: mode
        integer(kind=ip) intent(in) :: l
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: m
        real(kind=wp) dimension(:),intent(in) :: w
        real(kind=wp) dimension(:),intent(out) :: pmn
        integer(kind=ip) intent(inout) :: km
    end subroutine legin
    subroutine legin1(mode,l,nlat,late,m,p0n,p1n,abel,bbel,cbel,pmn,km) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: mode
        integer(kind=ip) intent(in) :: l
        integer(kind=ip), optional,intent(in),check(shape(p0n, 0) == nlat),depend(p0n) :: nlat=shape(p0n, 0)
        integer(kind=ip), optional,intent(in),check(shape(p0n, 1) == late),depend(p0n) :: late=shape(p0n, 1)
        integer(kind=ip) intent(in) :: m
        real(kind=wp) dimension(nlat,late),intent(in) :: p0n
        real(kind=wp) dimension(nlat,late),intent(in),depend(nlat,late) :: p1n
        real(kind=wp) dimension(:),intent(in) :: abel
        real(kind=wp) dimension(:),intent(in) :: bbel
        real(kind=wp) dimension(:),intent(in) :: cbel
        real(kind=wp) dimension(nlat,late,3),intent(out),depend(nlat,late) :: pmn
        integer(kind=ip) intent(inout) :: km
    end subroutine legin1
    subroutine zfin(isym,nlat,nlon,m,z,i3,wzfin) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: m
        real(kind=wp) dimension(:),intent(inout) :: z
        integer(kind=ip) intent(inout) :: i3
        real(kind=wp) dimension(:),intent(in) :: wzfin
    end subroutine zfin
    subroutine zfin1(isym,nlat,m,z,imid,i3,zz,z1,a,b,c) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(z, 1) == nlat),depend(z) :: nlat=shape(z, 1)
        integer(kind=ip) intent(in) :: m
        real(kind=wp) dimension(imid,nlat,3),intent(inout) :: z
        integer(kind=ip), optional,intent(in),check(shape(z, 0) == imid),depend(z) :: imid=shape(z, 0)
        integer(kind=ip) intent(inout) :: i3
        real(kind=wp) dimension(imid,*),intent(in),depend(imid) :: zz
        real(kind=wp) dimension(imid,*),intent(in),depend(imid) :: z1
        real(kind=wp) dimension(:),intent(in) :: a
        real(kind=wp) dimension(:),intent(in) :: b
        real(kind=wp) dimension(:),intent(in) :: c
    end subroutine zfin1
    subroutine zfinit(nlat,nlon,wzfin,dwork) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(:),intent(inout) :: wzfin
        real(kind=wp) dimension(:),intent(inout) :: dwork
    end subroutine zfinit
    subroutine zfini1(nlat,nlon,imid,z,abc,cz,work) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: imid
        real(kind=wp) dimension(imid,nlat,2),intent(out),depend(nlat,imid) :: z
        real(kind=wp) dimension(:),intent(out) :: abc
        real(kind=wp) dimension(:),intent(inout) :: cz
        real(kind=wp) dimension(:),intent(inout) :: work
    end subroutine zfini1
    subroutine dnzfk(nlat,m,n,cz,work) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: m
        integer(kind=ip) intent(in) :: n
        real(kind=wp) dimension(:),intent(out) :: cz
        real(kind=wp) dimension(:),intent(inout) :: work
    end subroutine dnzfk
    subroutine dnzft(nlat,m,n,th,cz,zh) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: m
        integer(kind=ip) intent(in) :: n
        real(kind=wp) intent(in) :: th
        real(kind=wp) dimension(:),intent(in) :: cz
        real(kind=wp) intent(out) :: zh
    end subroutine dnzft
    subroutine alin(isym,nlat,nlon,m,p,i3,walin) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: m
        real(kind=wp) dimension(:),intent(inout) :: p
        integer(kind=ip) intent(inout) :: i3
        real(kind=wp) dimension(:),intent(in) :: walin
    end subroutine alin
    subroutine alin1(isym,nlat,m,p,imid,i3,pz,p1,a,b,c) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(p, 1) == nlat),depend(p) :: nlat=shape(p, 1)
        integer(kind=ip) intent(in) :: m
        real(kind=wp) dimension(imid,nlat,3),intent(inout) :: p
        integer(kind=ip), optional,intent(in),check(shape(p, 0) == imid),depend(p) :: imid=shape(p, 0)
        integer(kind=ip) intent(inout) :: i3
        real(kind=wp) dimension(imid,*),intent(in),depend(imid) :: pz
        real(kind=wp) dimension(imid,*),intent(in),depend(imid) :: p1
        real(kind=wp) dimension(:),intent(in) :: a
        real(kind=wp) dimension(:),intent(in) :: b
        real(kind=wp) dimension(:),intent(in) :: c
    end subroutine alin1
    subroutine alinit(nlat,nlon,walin,dwork) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(:),intent(inout) :: walin
        real(kind=wp) dimension(:),intent(inout) :: dwork
    end subroutine alinit
    subroutine alini1(nlat,nlon,imid,p,abc,cp) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: imid
        real(kind=wp) dimension(imid,nlat,2),intent(out),depend(nlat,imid) :: p
        real(kind=wp) dimension(:),intent(out) :: abc
        real(kind=wp) dimension(:),intent(inout) :: cp
    end subroutine alini1
    subroutine rabcp(nlat,nlon,abc) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(:),intent(out) :: abc
    end subroutine rabcp
    subroutine rabcp1(nlat,nlon,a,b,c) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(:),intent(out) :: a
        real(kind=wp) dimension(:),intent(out) :: b
        real(kind=wp) dimension(:),intent(out) :: c
    end subroutine rabcp1
    subroutine sea1(nlat,nlon,imid,z,idz,zin,wzfin,dwork) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip), optional,intent(in),check(shape(zin, 1) == nlat),depend(zin) :: nlat=shape(zin, 1)
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip), optional,intent(in),check(shape(zin, 0) == imid),depend(zin) :: imid=shape(zin, 0)
        real(kind=wp) dimension(idz,*),intent(out),depend(idz) :: z
        integer(kind=ip) intent(in) :: idz
        real(kind=wp) dimension(imid,nlat,3),intent(inout) :: zin
        real(kind=wp) dimension(:),intent(inout) :: wzfin
        real(kind=wp) dimension(:),intent(inout) :: dwork
    end subroutine sea1
    subroutine ses1(nlat,nlon,imid,p,pin,walin,dwork) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip), optional,intent(in),check(shape(pin, 1) == nlat),depend(pin) :: nlat=shape(pin, 1)
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip), optional,intent(in),check(shape(pin, 0) == imid),depend(pin) :: imid=shape(pin, 0)
        real(kind=wp) dimension(imid,*),intent(out),depend(imid) :: p
        real(kind=wp) dimension(imid,nlat,3),intent(inout) :: pin
        real(kind=wp) dimension(:),intent(inout) :: walin
        real(kind=wp) dimension(:),intent(inout) :: dwork
    end subroutine ses1
    subroutine zvinit(nlat,nlon,wzvin,dwork) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(:),intent(out) :: wzvin
        real(kind=wp) dimension(:),intent(inout) :: dwork
    end subroutine zvinit
    subroutine zvini1(nlat,nlon,imid,zv,abc,czv,work) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: imid
        real(kind=wp) dimension(imid,nlat,2),intent(out),depend(nlat,imid) :: zv
        real(kind=wp) dimension(:),intent(out) :: abc
        real(kind=wp) dimension(:),intent(inout) :: czv
        real(kind=wp) dimension(:),intent(inout) :: work
    end subroutine zvini1
    subroutine zwinit(nlat,nlon,wzwin,dwork) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(:),intent(out) :: wzwin
        real(kind=wp) dimension(:),intent(inout) :: dwork
    end subroutine zwinit
    subroutine zwini1(nlat,nlon,imid,zw,abc,czw,work) ! in src/sphcom.f90:sphcom_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: imid
        real(kind=wp) dimension(imid,nlat,2),intent(out),depend(nlat,imid) :: zw
        real(kind=wp) dimension(:),intent(out) :: abc
        real(kind=wp) dimension(:),intent(inout) :: czw
        real(kind=wp) dimension(:),intent(inout) :: work
    end subroutine zwini1
    subroutine zwin(ityp,nlat,nlon,m,zw,i3,wzwin) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: ityp
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        integer intent(in) :: m
        real(kind=8) dimension(*),intent(inout) :: zw
        integer intent(in) :: i3
        real(kind=8) dimension(*),intent(in) :: wzwin
    end subroutine zwin
    subroutine zwin1(ityp,nlat,m,zw,imid,i3,zw1,zw2,a,b,c) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: ityp
        integer intent(in) :: nlat
        integer intent(in) :: m
        real(kind=8) dimension(*),intent(inout) :: zw
        integer intent(in) :: imid
        integer intent(in) :: i3
        real(kind=8) dimension(*),intent(inout) :: zw1
        real(kind=8) dimension(*),intent(inout) :: zw2
        real(kind=8) dimension(*),intent(in) :: a
        real(kind=8) dimension(*),intent(in) :: b
        real(kind=8) dimension(*),intent(in) :: c
    end subroutine zwin1
    subroutine vbinit(nlat,nlon,wvbin,dwork) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        real(kind=8) dimension(*),intent(out) :: wvbin
        real(kind=8) dimension(*),intent(inout) :: dwork
    end subroutine vbinit
    subroutine vbini1(nlat,nlon,imid,vb,abc,cvb,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        integer intent(in) :: imid
        real(kind=8) dimension(*),intent(inout) :: vb
        real(kind=8) dimension(*),intent(inout) :: abc
        real(kind=8) dimension(*),intent(inout) :: cvb
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine vbini1
    subroutine wbinit(nlat,nlon,wwbin,dwork) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        real(kind=8) dimension(*),intent(out) :: wwbin
        real(kind=8) dimension(*),intent(inout) :: dwork
    end subroutine wbinit
    subroutine wbini1(nlat,nlon,imid,wb,abc,cwb,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        integer intent(in) :: imid
        real(kind=8) dimension(*),intent(inout) :: wb
        real(kind=8) dimension(*),intent(inout) :: abc
        real(kind=8) dimension(*),intent(inout) :: cwb
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine wbini1
    subroutine vbin(ityp,nlat,nlon,m,vb,i3,wvbin) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: ityp
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        integer intent(in) :: m
        real(kind=8) dimension(*),intent(inout) :: vb
        integer intent(in) :: i3
        real(kind=8) dimension(*),intent(in) :: wvbin
    end subroutine vbin
    subroutine vbin1(ityp,nlat,m,vb,imid,i3,vbz,vb1,a,b,c) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: ityp
        integer intent(in) :: nlat
        integer intent(in) :: m
        real(kind=8) dimension(*),intent(inout) :: vb
        integer intent(in) :: imid
        integer intent(in) :: i3
        real(kind=8) dimension(*),intent(inout) :: vbz
        real(kind=8) dimension(*),intent(inout) :: vb1
        real(kind=8) dimension(*),intent(in) :: a
        real(kind=8) dimension(*),intent(in) :: b
        real(kind=8) dimension(*),intent(in) :: c
    end subroutine vbin1
    subroutine wbin(ityp,nlat,nlon,m,wb,i3,wwbin) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: ityp
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        integer intent(in) :: m
        real(kind=8) dimension(*),intent(inout) :: wb
        integer intent(in) :: i3
        real(kind=8) dimension(*),intent(in) :: wwbin
    end subroutine wbin
    subroutine wbin1(ityp,nlat,m,wb,imid,i3,wb1,wb2,a,b,c) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: ityp
        integer intent(in) :: nlat
        integer intent(in) :: m
        real(kind=8) dimension(*),intent(inout) :: wb
        integer intent(in) :: imid
        integer intent(in) :: i3
        real(kind=8) dimension(*),intent(inout) :: wb1
        real(kind=8) dimension(*),intent(inout) :: wb2
        real(kind=8) dimension(*),intent(in) :: a
        real(kind=8) dimension(*),intent(in) :: b
        real(kind=8) dimension(*),intent(in) :: c
    end subroutine wbin1
    subroutine dzvk(nlat,m,n,czv,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: m
        integer intent(in) :: n
        real(kind=8) dimension(*),intent(inout) :: czv
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine dzvk
    subroutine dzvt(nlat,m,n,th,czv,zvh) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: m
        integer intent(in) :: n
        real(kind=8) dimension(*),intent(in) :: th
        real(kind=8) dimension(*),intent(in) :: czv
        real(kind=8) dimension(*),intent(out) :: zvh
    end subroutine dzvt
    subroutine dzwk(nlat,m,n,czw,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: m
        integer intent(in) :: n
        real(kind=8) dimension(*),intent(inout) :: czw
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine dzwk
    subroutine dzwt(nlat,m,n,th,czw,zwh) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: m
        integer intent(in) :: n
        real(kind=8) dimension(*),intent(in) :: th
        real(kind=8) dimension(*),intent(in) :: czw
        real(kind=8) dimension(*),intent(out) :: zwh
    end subroutine dzwt
    subroutine dvbk(m,n,cv,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: m
        integer intent(in) :: n
        real(kind=8) dimension(*),intent(inout) :: cv
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine dvbk
    subroutine dvbt(m,n,theta,cv,vh) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: m
        integer intent(in) :: n
        real(kind=8) dimension(*),intent(in) :: theta
        real(kind=8) dimension(*),intent(in) :: cv
        real(kind=8) dimension(*),intent(out) :: vh
    end subroutine dvbt
    subroutine dwbk(m,n,cw,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: m
        integer intent(in) :: n
        real(kind=8) dimension(*),intent(inout) :: cw
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine dwbk
    subroutine dwbt(m,n,theta,cw,wh) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: m
        integer intent(in) :: n
        real(kind=8) dimension(*),intent(in) :: theta
        real(kind=8) dimension(*),intent(in) :: cw
        real(kind=8) dimension(*),intent(out) :: wh
    end subroutine dwbt
    subroutine rabcv(nlat,nlon,abc) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        real(kind=8) dimension(*),intent(out) :: abc
    end subroutine rabcv
    subroutine rabcv1(nlat,nlon,a,b,c) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        real(kind=8) dimension(*),intent(out) :: a
        real(kind=8) dimension(*),intent(out) :: b
        real(kind=8) dimension(*),intent(out) :: c
    end subroutine rabcv1
    subroutine rabcw(nlat,nlon,abc) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        real(kind=8) dimension(*),intent(out) :: abc
    end subroutine rabcw
    subroutine rabcw1(nlat,nlon,a,b,c) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        real(kind=8) dimension(*),intent(out) :: a
        real(kind=8) dimension(*),intent(out) :: b
        real(kind=8) dimension(*),intent(out) :: c
    end subroutine rabcw1
    subroutine vtinit(nlat,nlon,wvbin,dwork) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        real(kind=8) dimension(*),intent(out) :: wvbin
        real(kind=8) dimension(*),intent(inout) :: dwork
    end subroutine vtinit
    subroutine vtini1(nlat,nlon,imid,vb,abc,cvb,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        integer intent(in) :: imid
        real(kind=8) dimension(*),intent(inout) :: vb
        real(kind=8) dimension(*),intent(inout) :: abc
        real(kind=8) dimension(*),intent(inout) :: cvb
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine vtini1
    subroutine wtinit(nlat,nlon,wwbin,dwork) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        real(kind=8) dimension(*),intent(out) :: wwbin
        real(kind=8) dimension(*),intent(inout) :: dwork
    end subroutine wtinit
    subroutine wtini1(nlat,nlon,imid,wb,abc,cwb,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        integer intent(in) :: imid
        real(kind=8) dimension(*),intent(inout) :: wb
        real(kind=8) dimension(*),intent(inout) :: abc
        real(kind=8) dimension(*),intent(inout) :: cwb
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine wtini1
    subroutine vtgint(nlat,nlon,theta,wvbin,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        real(kind=8) dimension(*),intent(in) :: theta
        real(kind=8) dimension(*),intent(inout) :: wvbin
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine vtgint
    subroutine vtgit1(nlat,nlon,imid,theta,vb,abc,cvb,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        integer intent(in) :: imid
        real(kind=8) dimension(*),intent(in) :: theta
        real(kind=8) dimension(*),intent(inout) :: vb
        real(kind=8) dimension(*),intent(inout) :: abc
        real(kind=8) dimension(*),intent(inout) :: cvb
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine vtgit1
    subroutine wtgint(nlat,nlon,theta,wwbin,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        real(kind=8) dimension(*),intent(in) :: theta
        real(kind=8) dimension(*),intent(inout) :: wwbin
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine wtgint
    subroutine wtgit1(nlat,nlon,imid,theta,wb,abc,cwb,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        integer intent(in) :: imid
        real(kind=8) dimension(*),intent(in) :: theta
        real(kind=8) dimension(*),intent(inout) :: wb
        real(kind=8) dimension(*),intent(inout) :: abc
        real(kind=8) dimension(*),intent(inout) :: cwb
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine wtgit1
    subroutine dvtk(m,n,cv,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: m
        integer intent(in) :: n
        real(kind=8) dimension(*),intent(inout) :: cv
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine dvtk
    subroutine dvtt(m,n,theta,cv,vh) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: m
        integer intent(in) :: n
        real(kind=8) dimension(*),intent(in) :: theta
        real(kind=8) dimension(*),intent(in) :: cv
        real(kind=8) dimension(*),intent(out) :: vh
    end subroutine dvtt
    subroutine dwtk(m,n,cw,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: m
        integer intent(in) :: n
        real(kind=8) dimension(*),intent(inout) :: cw
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine dwtk
    subroutine dwtt(m,n,theta,cw,wh) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: m
        integer intent(in) :: n
        real(kind=8) dimension(*),intent(in) :: theta
        real(kind=8) dimension(*),intent(in) :: cw
        real(kind=8) dimension(*),intent(out) :: wh
    end subroutine dwtt
    subroutine vbgint(nlat,nlon,theta,wvbin,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        real(kind=8) dimension(*),intent(in) :: theta
        real(kind=8) dimension(*),intent(inout) :: wvbin
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine vbgint
    subroutine vbgit1(nlat,nlon,imid,theta,vb,abc,cvb,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        integer intent(in) :: imid
        real(kind=8) dimension(*),intent(in) :: theta
        real(kind=8) dimension(*),intent(inout) :: vb
        real(kind=8) dimension(*),intent(inout) :: abc
        real(kind=8) dimension(*),intent(inout) :: cvb
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine vbgit1
    subroutine wbgint(nlat,nlon,theta,wwbin,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        real(kind=8) dimension(*),intent(in) :: theta
        real(kind=8) dimension(*),intent(inout) :: wwbin
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine wbgint
    subroutine wbgit1(nlat,nlon,imid,theta,wb,abc,cwb,work) ! in src/sphcom.f90:sphcom_mod
        integer intent(in) :: nlat
        integer intent(in) :: nlon
        integer intent(in) :: imid
        real(kind=8) dimension(*),intent(in) :: theta
        real(kind=8) dimension(*),intent(inout) :: wb
        real(kind=8) dimension(*),intent(inout) :: abc
        real(kind=8) dimension(*),intent(inout) :: cwb
        real(kind=8) dimension(*),intent(inout) :: work
    end subroutine wbgit1
end module sphcom_mod
module hrfft_mod ! in src/hrfft.f90
    subroutine hrffti(n,wsave) ! in src/hrfft.f90:hrfft_mod
        integer intent(in) :: n
        real dimension(15 + n),intent(out),depend(n) :: wsave
    end subroutine hrffti
    subroutine hrfftf(m,n,r,mdimr,whrfft,work) ! in src/hrfft.f90:hrfft_mod
        integer intent(in) :: m
        integer, optional,intent(in),check(shape(r, 1) == n),depend(r) :: n=shape(r, 1)
        real dimension(mdimr,n),intent(inout) :: r
        integer, optional,intent(in),check(shape(r, 0) == mdimr),depend(r) :: mdimr=shape(r, 0)
        real dimension(15 + n),intent(in),depend(n) :: whrfft
        real dimension(*),intent(inout) :: work
    end subroutine hrfftf
    subroutine hrfftb(m,n,r,mdimr,whrfft,work) ! in src/hrfft.f90:hrfft_mod
        integer intent(in) :: m
        integer, optional,intent(in),check(shape(r, 1) == n),depend(r) :: n=shape(r, 1)
        real dimension(mdimr,n),intent(inout) :: r
        integer, optional,intent(in),check(shape(r, 0) == mdimr),depend(r) :: mdimr=shape(r, 0)
        real dimension(15 + n),intent(in),depend(n) :: whrfft
        real dimension(*),intent(inout) :: work
    end subroutine hrfftb
end module hrfft_mod
subroutine getlegfunc(legfunc,lat,ntrunc) ! in src/getlegfunc.f90
    real dimension((2 + 3 * ntrunc + ntrunc * ntrunc) / 2),intent(out),depend(ntrunc) :: legfunc
    real intent(in) :: lat
    integer intent(in) :: ntrunc
end subroutine getlegfunc
subroutine specintrp(rlon,ntrunc,datnm,scrm,pnm,ob) ! in src/specintrp.f90
    real intent(in) :: rlon
    integer, required,intent(in) :: ntrunc
    complex dimension((2 + 3 * ntrunc + ntrunc * ntrunc) / 2),intent(in),check(shape(datnm, 0) == (2 + 3 * ntrunc + ntrunc * ntrunc) / 2),depend(ntrunc) :: datnm
    complex dimension(1 + ntrunc),intent(out),depend(ntrunc) :: scrm
    real dimension((2 + 3 * ntrunc + ntrunc * ntrunc) / 2),intent(in),check(shape(pnm, 0) == (2 + 3 * ntrunc + ntrunc * ntrunc) / 2),depend(ntrunc) :: pnm
    real intent(out) :: ob
end subroutine specintrp
subroutine onedtotwod(dataspec,a,b,nlat,nmdim,nt) ! in src/onedtotwod.f90
    complex dimension(nmdim,nt),intent(in) :: dataspec
    real dimension(nlat,nlat,nt),intent(out),depend(nlat,nt) :: a
    real dimension(nlat,nlat,nt),intent(out),depend(nlat,nt) :: b
    integer intent(in) :: nlat
    integer, optional,intent(in),check(shape(dataspec, 0) == nmdim),depend(dataspec) :: nmdim=shape(dataspec, 0)
    integer, optional,intent(in),check(shape(dataspec, 1) == nt),depend(dataspec) :: nt=shape(dataspec, 1)
end subroutine onedtotwod
subroutine onedtotwod_vrtdiv(vrtspec,divspec,br,bi,cr,ci,nlat,nmdim,nt,rsphere) ! in src/onedtotwod_vrtdiv.f90
    complex dimension(nmdim,nt),intent(in) :: vrtspec
    complex dimension(nmdim,nt),intent(in),depend(nt,nmdim) :: divspec
    real dimension(nlat,nlat,nt),intent(out),depend(nlat,nt) :: br
    real dimension(nlat,nlat,nt),intent(out),depend(nlat,nt) :: bi
    real dimension(nlat,nlat,nt),intent(out),depend(nlat,nt) :: cr
    real dimension(nlat,nlat,nt),intent(out),depend(nlat,nt) :: ci
    integer intent(in) :: nlat
    integer, optional,intent(in),check(shape(vrtspec, 0) == nmdim),depend(vrtspec) :: nmdim=shape(vrtspec, 0)
    integer, optional,intent(in),check(shape(vrtspec, 1) == nt),depend(vrtspec) :: nt=shape(vrtspec, 1)
    real intent(in) :: rsphere
end subroutine onedtotwod_vrtdiv
subroutine twodtooned(dataspec,a,b,nlat,ntrunc,nt) ! in src/twodtooned.f90
    complex dimension((2 + 3 * ntrunc + ntrunc * ntrunc) / 2,nt),intent(out),depend(nt,ntrunc) :: dataspec
    real dimension(nlat,nlat,nt),intent(in) :: a
    real dimension(nlat,nlat,nt),intent(in),depend(nlat,nt) :: b
    integer, optional,intent(in),check(shape(a, 0) == nlat),depend(a) :: nlat=shape(a, 0)
    integer intent(in) :: ntrunc
    integer, optional,intent(in),check(shape(a, 2) == nt),depend(a) :: nt=shape(a, 2)
end subroutine twodtooned
subroutine twodtooned_vrtdiv(vrtspec,divspec,br,bi,cr,ci,nlat,ntrunc,nt,rsphere) ! in src/twodtooned_vrtdiv.f90
    complex dimension((2 + 3 * ntrunc + ntrunc * ntrunc) / 2,nt),intent(out),depend(nt,ntrunc) :: vrtspec
    complex dimension((2 + 3 * ntrunc + ntrunc * ntrunc) / 2,nt),intent(out),depend(nt,ntrunc) :: divspec
    real dimension(nlat,nlat,nt),intent(in) :: br
    real dimension(nlat,nlat,nt),intent(in),depend(nlat,nt) :: bi
    real dimension(nlat,nlat,nt),intent(in),depend(nlat,nt) :: cr
    real dimension(nlat,nlat,nt),intent(in),depend(nlat,nt) :: ci
    integer, optional,intent(in),check(shape(br, 0) == nlat),depend(br) :: nlat=shape(br, 0)
    integer intent(in) :: ntrunc
    integer, optional,intent(in),check(shape(br, 2) == nt),depend(br) :: nt=shape(br, 2)
    real intent(in) :: rsphere
end subroutine twodtooned_vrtdiv
subroutine multsmoothfact(dataspec,dataspec_smooth,smooth,nlat,nmdim,nt) ! in src/multsmoothfact.f90
    complex dimension(nmdim,nt),intent(in) :: dataspec
    complex dimension(nmdim,nt),intent(out),depend(nt,nmdim) :: dataspec_smooth
    real dimension(nlat),intent(in) :: smooth
    integer, optional,intent(in),check(shape(smooth, 0) == nlat),depend(smooth) :: nlat=shape(smooth, 0)
    integer, optional,intent(in),check(shape(dataspec, 0) == nmdim),depend(dataspec) :: nmdim=shape(dataspec, 0)
    integer, optional,intent(in),check(shape(dataspec, 1) == nt),depend(dataspec) :: nt=shape(dataspec, 1)
end subroutine multsmoothfact
subroutine lap(dataspec,dataspec_lap,nmdim,nt,rsphere) ! in src/lap.f90
    complex dimension(nmdim,nt),intent(in) :: dataspec
    complex dimension(nmdim,nt),intent(out),depend(nt,nmdim) :: dataspec_lap
    integer, optional,intent(in),check(shape(dataspec, 0) == nmdim),depend(dataspec) :: nmdim=shape(dataspec, 0)
    integer, optional,intent(in),check(shape(dataspec, 1) == nt),depend(dataspec) :: nt=shape(dataspec, 1)
    real intent(in) :: rsphere
end subroutine lap
subroutine invlap(dataspec,dataspec_ilap,nmdim,nt,rsphere) ! in src/invlap.f90
    complex dimension(nmdim,nt),intent(in) :: dataspec
    complex dimension(nmdim,nt),intent(out),depend(nt,nmdim) :: dataspec_ilap
    integer, optional,intent(in),check(shape(dataspec, 0) == nmdim),depend(dataspec) :: nmdim=shape(dataspec, 0)
    integer, optional,intent(in),check(shape(dataspec, 1) == nt),depend(dataspec) :: nt=shape(dataspec, 1)
    real intent(in) :: rsphere
end subroutine invlap
subroutine gaqd(nlat,theta,wts,w,lwork,ierror) ! in src/gaqd.f90
    integer intent(in) :: nlat
    real(kind=8) dimension(nlat),intent(out),depend(nlat) :: theta
    real(kind=8) dimension(nlat),intent(out),depend(nlat) :: wts
    real(kind=8) intent(in) :: w
    integer intent(in) :: lwork
    integer intent(out) :: ierror
end subroutine gaqd
subroutine cpdp(n,cz,cp,dcp) ! in src/gaqd.f90
    integer intent(in) :: n
    real(kind=8) intent(out) :: cz
    real(kind=8) dimension(1 + n / 2),intent(out),depend(n) :: cp
    real(kind=8) dimension(1 + n / 2),intent(out),depend(n) :: dcp
end subroutine cpdp
subroutine tpdp(n,theta,cz,cp,dcp,pb,dpb) ! in src/gaqd.f90
    integer, optional,intent(in),check(shape(cp, 0) == 1 + n / 2),depend(cp) :: n=(-2 + 2 * shape(cp, 0)) / 1
    real(kind=8) intent(in) :: theta
    real(kind=8) intent(in) :: cz
    real(kind=8) dimension(1 + n / 2),intent(in) :: cp
    real(kind=8) dimension(1 + n / 2),intent(in),depend(n) :: dcp
    real(kind=8) intent(out) :: pb
    real(kind=8) intent(out) :: dpb
end subroutine tpdp
function dzeps(x) ! in src/gaqd.f90
    real(kind=8) intent(in) :: x
    real(kind=8) :: dzeps
end function dzeps
module shses_mod ! in src/shses.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine shses(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/shses.f90:shses_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shses
    subroutine shsesi(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/shses.f90:shses_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shsesi
end module shses_mod
module shaes_mod ! in src/shaes.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine shaes(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/shaes.f90:shaes_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shaes
    subroutine shaesi(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/shaes.f90:shaes_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shaesi
end module shaes_mod
module vhaes_mod ! in src/vhaes.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine vhaes(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/vhaes.f90:vhaes_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhaes
    subroutine vhaesi(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/vhaes.f90:vhaes_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhaesi
end module vhaes_mod
module vhses_mod ! in src/vhses.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine vhses(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/vhses.f90:vhses_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhses
    subroutine vhsesi(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/vhses.f90:vhses_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhsesi
end module vhses_mod
module shsgs_mod ! in src/shsgs.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine shsgs(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/shsgs.f90:shsgs_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shsgs
    subroutine shsgsi(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/shsgs.f90:shsgs_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shsgsi
end module shsgs_mod
module shags_mod ! in src/shags.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine shags(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/shags.f90:shags_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shags
    subroutine shagsi(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/shags.f90:shags_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shagsi
end module shags_mod
module vhags_mod ! in src/vhags.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine vhags(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/vhags.f90:vhags_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhags
    subroutine vhagsi(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/vhags.f90:vhags_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhagsi
end module vhags_mod
module vhsgs_mod ! in src/vhsgs.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine vhsgs(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/vhsgs.f90:vhsgs_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhsgs
    subroutine vhsgsi(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/vhsgs.f90:vhsgs_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhsgsi
end module vhsgs_mod
module shaec_mod ! in src/shaec.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine shaec(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/shaec.f90:shaec_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shaec
    subroutine shaeci(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/shaec.f90:shaec_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shaeci
end module shaec_mod
module shagc_mod ! in src/shagc.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine shagc(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/shagc.f90:shagc_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shagc
    subroutine shagci(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/shagc.f90:shagc_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shagci
end module shagc_mod
module shsec_mod ! in src/shsec.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine shsec(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/shsec.f90:shsec_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shsec
    subroutine shseci(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/shsec.f90:shsec_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shseci
end module shsec_mod
module shsgc_mod ! in src/shsgc.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine shsgc(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/shsgc.f90:shsgc_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shsgc
    subroutine shsgci(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/shsgc.f90:shsgc_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine shsgci
end module shsgc_mod
module vhaec_mod ! in src/vhaec.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine vhaec(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/vhaec.f90:vhaec_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhaec
    subroutine vhaeci(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/vhaec.f90:vhaec_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhaeci
end module vhaec_mod
module vhagc_mod ! in src/vhagc.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine vhagc(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/vhagc.f90:vhagc_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhagc
    subroutine vhagci(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/vhagc.f90:vhagc_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhagci
end module vhagc_mod
module vhsec_mod ! in src/vhsec.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine vhsec(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/vhsec.f90:vhsec_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhsec
    subroutine vhseci(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/vhsec.f90:vhsec_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhseci
end module vhsec_mod
module vhsgc_mod ! in src/vhsgc.f90
    use iso_fortran_env, only: real64,int32
    use sphcom_mod
    use hrfft_mod
    integer, private,parameter,optional :: wp=real64
    integer, private,parameter,optional :: ip=int32
    real(kind=real64), private,parameter,optional :: pi=3.14159265358979323846264338327950288419716939937510_wp
    subroutine vhsgc(nlat,nlon,isym,nt,g,idg,jdg,a,b,mdab,ndab,wshags,lshags,work,lwork,ierror) ! in src/vhsgc.f90:vhsgc_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        integer(kind=ip) intent(in) :: isym
        integer(kind=ip), optional,intent(in),check(shape(g, 2) == nt),depend(g) :: nt=shape(g, 2)
        real(kind=wp) dimension(idg,jdg,nt),intent(inout) :: g
        integer(kind=ip), optional,intent(in),check(shape(g, 0) == idg),depend(g) :: idg=shape(g, 0)
        integer(kind=ip), optional,intent(in),check(shape(g, 1) == jdg),depend(g) :: jdg=shape(g, 1)
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: a
        real(kind=wp) dimension(mdab,ndab,nt),intent(out),depend(ndab,nt,mdab) :: b
        integer(kind=ip) intent(in) :: mdab
        integer(kind=ip) intent(in) :: ndab
        real(kind=wp) dimension(lshags),intent(inout) :: wshags
        integer(kind=ip), optional,intent(in),check(shape(wshags, 0) == lshags),depend(wshags) :: lshags=shape(wshags, 0)
        real(kind=wp) dimension(lwork),intent(inout) :: work
        integer(kind=ip), optional,intent(in),check(shape(work, 0) == lwork),depend(work) :: lwork=shape(work, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhsgc
    subroutine vhsgci(nlat,nlon,wshags,lshags,dwork,ldwork,ierror) ! in src/vhsgc.f90:vhsgc_mod
        integer(kind=ip) intent(in) :: nlat
        integer(kind=ip) intent(in) :: nlon
        real(kind=wp) dimension(lshags),intent(out),depend(lshags) :: wshags
        integer(kind=ip) intent(in) :: lshags
        real(kind=wp) dimension(ldwork),intent(inout) :: dwork
        integer(kind=ip), optional,intent(in),check(shape(dwork, 0) == ldwork),depend(dwork) :: ldwork=shape(dwork, 0)
        integer(kind=ip) intent(out) :: ierror
    end subroutine vhsgci
end module vhsgc_mod
subroutine ihgeod(m,idp,jdp,x,y,z) ! in src/ihgeod.f90
    integer intent(in) :: m
    integer intent(in) :: idp
    integer intent(in) :: jdp
    real dimension(idp,jdp,5),intent(out),depend(idp,jdp) :: x
    real dimension(idp,jdp,5),intent(out),depend(idp,jdp) :: y
    real dimension(idp,jdp,5),intent(out),depend(idp,jdp) :: z
end subroutine ihgeod
subroutine ctos(x,y,z,r,theta,phi) ! in src/ihgeod.f90
    real intent(in) :: x
    real intent(in) :: y
    real intent(in) :: z
    real intent(out) :: r
    real intent(out) :: theta
    real intent(out) :: phi
end subroutine ctos
subroutine stoc(r,theta,phi,x,y,z) ! in src/ihgeod.f90
    real intent(in) :: r
    real intent(in) :: theta
    real intent(in) :: phi
    real intent(out) :: x
    real intent(out) :: y
    real intent(out) :: z
end subroutine stoc
subroutine alfk(n,m,cp) ! in src/alf.f90
    integer intent(in) :: n
    integer intent(in) :: m
    real dimension(1 + n / 2),intent(out),depend(n) :: cp
end subroutine alfk
subroutine lfim(init,theta,l,n,nm,pb,id,wlfim) ! in src/alf.f90
    integer intent(in) :: init
    real dimension(l),intent(in) :: theta
    integer, optional,intent(in),check(shape(theta, 0) == l),depend(theta) :: l=shape(theta, 0)
    integer intent(in) :: n
    integer intent(in) :: nm
    real dimension(id,*),intent(inout) :: pb
    integer, optional,intent(in),check(shape(pb, 0) == id),depend(pb) :: id=shape(pb, 0)
    real dimension(*),intent(inout) :: wlfim
end subroutine lfim
subroutine lfim1(init,theta,l,n,nm,id,p3,phz,ph1,p1,p2,cp) ! in src/alf.f90
    integer intent(in) :: init
    real dimension(l),intent(in) :: theta
    integer, optional,intent(in),check(shape(theta, 0) == l),depend(theta) :: l=shape(theta, 0)
    integer intent(in) :: n
    integer intent(in) :: nm
    integer, optional,intent(in),check(shape(p3, 0) == id),depend(p3) :: id=shape(p3, 0)
    real dimension(id,*),intent(inout) :: p3
    real dimension(l,*),intent(inout),depend(l) :: phz
    real dimension(l,*),intent(inout),depend(l) :: ph1
    real dimension(l,*),intent(inout),depend(l) :: p1
    real dimension(l,*),intent(inout),depend(l) :: p2
    real dimension(*),intent(inout) :: cp
end subroutine lfim1
subroutine lfin(init,theta,l,m,nm,pb,id,wlfin) ! in src/alf.f90
    integer intent(in) :: init
    real dimension(l),intent(in) :: theta
    integer, optional,intent(in),check(shape(theta, 0) == l),depend(theta) :: l=shape(theta, 0)
    integer intent(in) :: m
    integer intent(in) :: nm
    real dimension(id,*),intent(inout) :: pb
    integer, optional,intent(in),check(shape(pb, 0) == id),depend(pb) :: id=shape(pb, 0)
    real dimension(*),intent(inout) :: wlfin
end subroutine lfin
subroutine lfin1(init,theta,l,m,nm,id,p3,phz,ph1,p1,p2,cp) ! in src/alf.f90
    integer intent(in) :: init
    real dimension(l),intent(in) :: theta
    integer, optional,intent(in),check(shape(theta, 0) == l),depend(theta) :: l=shape(theta, 0)
    integer intent(in) :: m
    integer intent(in) :: nm
    integer, optional,intent(in),check(shape(p3, 0) == id),depend(p3) :: id=shape(p3, 0)
    real dimension(id,*),intent(inout) :: p3
    real dimension(l,*),intent(inout),depend(l) :: phz
    real dimension(l,*),intent(inout),depend(l) :: ph1
    real dimension(l,*),intent(inout),depend(l) :: p1
    real dimension(l,*),intent(inout),depend(l) :: p2
    real dimension(*),intent(inout) :: cp
end subroutine lfin1
subroutine lfpt(n,m,theta,cp,pb) ! in src/alf.f90
    integer intent(in) :: n
    integer intent(in) :: m
    real intent(in) :: theta
    real dimension(*),intent(in) :: cp
    real intent(out) :: pb
end subroutine lfpt

! This file was auto-generated with f2py (version:1.26.4).
! See:
! https://web.archive.org/web/20140822061353/http://cens.ioc.ee/projects/f2py2e
